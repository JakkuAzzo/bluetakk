import asyncio
import os
import glob
import json
import datetime
import matplotlib.pyplot as plt
import numpy as np

from bleak import BleakScanner, BleakClient
from bleak.exc import BleakDeviceNotFoundError

# ---------------- Utility Functions ----------------

def is_potential_shell_characteristic(characteristic):
    """
    Determines if a characteristic might be a command interface based on its properties.
    """
    return ("write" in characteristic.properties or 
            "write_without_response" in characteristic.properties)

async def scan_nearby_devices():
    """
    Scan for all nearby BLE devices and return a list of devices with exploitable services.
    """
    devices = await BleakScanner.discover()
    vulnerable_devices = []
    for device in devices:
        exploitable_services = await scan_and_identify_exploitable_services(device.address)
        if exploitable_services:
            vulnerable_devices.append({
                "device_name": device.name,
                "device_address": device.address,
                "exploitable_services": exploitable_services
            })
    return vulnerable_devices

async def scan_and_identify_exploitable_services(device_address):
    """
    Scan a BLE device for writable characteristics that may allow command execution.
    """
    exploitable_services = []
    try:
        async with BleakClient(device_address) as client:
            print("Scanning device", device_address)
            services = await client.get_services()
            for service in services:
                for char in service.characteristics:
                    if is_potential_shell_characteristic(char):
                        exploitable_services.append({
                            "service_uuid": service.uuid,
                            "char_uuid": char.uuid,
                            "properties": char.properties
                        })
    except Exception as e:
        print(f"Error scanning {device_address}: {e}")
    return exploitable_services

async def exploit_device(device_address, char_uuid):
    """
    Attempt to send a variety of test commands to a writable characteristic.
    Prints the command being sent before executing each test.
    Returns a list of the test results.
    """
    test_commands = [
        {"name": "Buffer Overflow", "command": "A" * 512},
        {"name": "Alphanumeric", "command": "abc123"},
        {"name": "Integers Only", "command": "1234567890"},
        {"name": "Letters Only", "command": "abcdefg"},
        {"name": "Zero Width", "command": "\u200b" * 50},
    ]
    results = []
    async with BleakClient(device_address) as client:
        for test in test_commands:
            cmd = test["command"]
            print(f"Testing {test['name']} on {char_uuid} with command: {cmd}")
            try:
                # Send the command.
                await client.write_gatt_char(char_uuid, cmd.encode())
                # Wait for a response.
                response = await client.read_gatt_char(char_uuid)
                decoded = response.decode(errors='ignore')
            except Exception as e:
                decoded = f"Error: {str(e)}"
            results.append({
                "test_name": test["name"],
                "command": cmd,
                "response": decoded
            })
    return results

async def safe_exploit_device(device_address, char_uuid):
    try:
        result = await exploit_device(device_address, char_uuid)
        return result
    except BleakDeviceNotFoundError as e:
        print(f"Device {device_address} not found on char {char_uuid}: {e}")
        return {"error": f"Device {device_address} not found"}
    except Exception as e:
        print(f"Error exploiting device {device_address} on char {char_uuid}: {e}")
        return {"error": str(e)}

async def enumerate_uuids(device_address):
    """
    Bruteforce a range of UUID variations to try and discover hidden characteristics.
    """
    base_uuid = "0000abcd-0000-1000-8000-00805f9b34fb"
    similar_uuids = [base_uuid[:-2] + f"{i:02x}" for i in range(256)]
    found = []
    async with BleakClient(device_address) as client:
        for uuid in similar_uuids:
            try:
                await client.write_gatt_char(uuid, b"test")
                print(f"Writable UUID found: {uuid}")
                found.append(uuid)
            except Exception:
                pass
    return found

def save_exploit_results(results):
    """
    Saves the exploitation results as a JSON file in a folder called recent_exploit.
    """
    folder = os.path.join(os.getcwd(), "recent_exploit")
    if not os.path.exists(folder):
        os.makedirs(folder)
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(folder, f"exploit_results_{timestamp}.json")
    with open(filename, "w") as f:
        json.dump(results, f, indent=4, default=str)
    print(f"Exploit results saved to {filename}")

def load_recent_scan():
    """
    Loads the most recent scan file (json) from the recent_scan folder.
    """
    recent_folder = os.path.join(os.getcwd(), "recent_scan")
    scan_files = glob.glob(os.path.join(recent_folder, "bleak_discover_*.json"))
    if not scan_files:
        print("No recent scan files found in recent_scan folder.")
        return None
    scan_files.sort(key=os.path.getmtime, reverse=True)
    recent_file = scan_files[0]
    with open(recent_file, "r") as f:
        data = json.load(f)
    return data

def load_all_exploit_results():
    """
    Loads all exploit result files from the recent_exploit folder and returns a combined list.
    Skips files that fail JSON decoding.
    """
    folder = os.path.join(os.getcwd(), "recent_exploit")
    files = glob.glob(os.path.join(folder, "exploit_results_*.json"))
    all_results = []
    for f in files:
        try:
            with open(f, "r") as file:
                data = json.load(file)
                all_results.extend(data)
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON file {f}: {e}. Skipping file.")
        except Exception as e:
            print(f"Error loading file {f}: {e}. Skipping file.")
    return all_results

# ---------------- Menu Option Implementations ----------------

async def option_exploit_single_device():
    """
    Option 1:
    List devices from recent scan, select one and exploit it.
    If no exploitable service is directly found, try to use the "details" field.
    If still nothing is found, ask user if brute-force should be attempted.
    Save test results to recent_exploit folder afterward.
    """
    data = load_recent_scan()
    if not data:
        return

    print("Recent scan devices:")
    for idx, device in enumerate(data, start=1):
        display_name = device.get("name") or "Unknown"
        print(f"{idx}. {display_name} - {device.get('address')}")
        
    try:
        choice = int(input("Select a device to exploit (number): "))
        selected = data[choice-1]
    except Exception:
        print("Invalid choice.")
        return

    device_address = selected.get("address")
    exploitable = selected.get("exploitable_services")
    details = selected.get("details", [])
    # If exploitable is empty but details exist, try to build exploitable from details.
    if (exploitable is None or len(exploitable) == 0) and details and len(details) > 0:
        exploitable = []
        for svc in details:
            if "characteristics" in svc and svc["characteristics"]:
                for char in svc["characteristics"]:
                    exploitable.append({
                        "service_uuid": svc.get("uuid"),
                        "char_uuid": char,
                        "properties": svc.get("properties", [])
                    })
    
    final_results = []
    if exploitable is None or len(exploitable) == 0:
        print("No writable characteristics found from scan results for this device.")
        ans = input("Attempt brute-force UUID enumeration? (y/n): ")
        if ans.lower().startswith("y"):
            brute_results = await enumerate_uuids(device_address)
            final_results.append({
                "device_address": device_address,
                "bruteforce": brute_results
            })
        else:
            print("Skipping exploitation for this device.")
            return
    else:
        for svc in exploitable:
            print(f"Exploiting service {svc.get('service_uuid')} / char {svc.get('char_uuid')} ...")
            test_results = await exploit_device(device_address, svc.get("char_uuid"))
            final_results.append({
                "device_address": device_address,
                "service_uuid": svc.get("service_uuid"),
                "char_uuid": svc.get("char_uuid"),
                "test_results": test_results
            })
    save_exploit_results(final_results)

async def option_exploit_all_devices():
    """
    Option 2:
    Exploit all devices from recent scan concurrently.
    Before launching, ask if brute-force should be attempted on any device with no exploitable services.
    Save aggregated results to recent_exploit folder.
    """
    data = load_recent_scan()
    if not data:
        return
    brute_force_all = input("Attempt brute-force on devices with no exploitable services? (y/n): ").lower().startswith("y")
    tasks = []
    results_all = []
    for device in data:
        device_address = device.get("address")
        exploitable = device.get("exploitable_services") if "exploitable_services" in device else None
        # Build exploitable list from details if needed.
        if (exploitable is None or len(exploitable)==0) and device.get("details", []):
            exploitable = []
            for svc in device["details"]:
                if "characteristics" in svc and svc["characteristics"]:
                    for char in svc["characteristics"]:
                        exploitable.append({
                            "service_uuid": svc.get("uuid"),
                            "char_uuid": char,
                            "properties": svc.get("properties", [])
                        })
        if exploitable is None or len(exploitable)==0:
            if brute_force_all:
                print(f"Brute forcing device {device_address} ...")
                tasks.append(enumerate_uuids(device_address))
                results_all.append({
                    "device_address": device_address,
                    "bruteforce": None  # Placeholder; result will be filled after await.
                })
            else:
                print(f"Skipping device {device_address} due to no exploitable services.")
        else:
            for svc in exploitable:
                print(f"Exploiting device {device_address} service {svc['service_uuid']} / char {svc['char_uuid']}")
                tasks.append(safe_exploit_device(device_address, svc['char_uuid']))
                results_all.append({
                    "device_address": device_address,
                    "service_uuid": svc.get("service_uuid"),
                    "char_uuid": svc.get("char_uuid"),
                    "test_results": None  # To be filled in after await.
                })
    if tasks:
        gathered = await asyncio.gather(*tasks, return_exceptions=True)
        # Map gathered results back to results_all entries.
        j = 0
        for i in range(len(results_all)):
            if results_all[i].get("test_results") is None and "bruteforce" not in results_all[i]:
                results_all[i]["test_results"] = gathered[j]
                j += 1
            elif results_all[i].get("bruteforce") is None and "bruteforce" in results_all[i]:
                results_all[i]["bruteforce"] = gathered[j]
                j += 1
        print("Finished all exploitation attempts.")
        save_exploit_results(results_all)
    else:
        print("No tasks were created.")

async def option_bruteforce_specific():
    """
    Option 3:
    Ask the user for a device address and bruteforce (enumerate) its possible UUIDs.
    Save the results to recent_exploit folder.
    """
    device_address = input("Enter the device address to bruteforce: ").strip()
    if not device_address:
        print("No address provided; exiting.")
        return
    found = await enumerate_uuids(device_address)
    result = {"device_address": device_address, "bruteforce": found}
    save_exploit_results([result])

async def option_scan_specific_with_uuids():
    """
    Option 4:
    Ask for a device address and one or more UUIDs.
    If at least one UUID is provided, test each and save results to recent_exploit folder.
    """
    device_address = input("Enter the device address to scan: ").strip()
    uuids = input("Enter one or more UUIDs (comma-separated) to test (leave blank to exit): ").strip()
    if not uuids:
        print("No UUID provided; exiting.")
        return
    uuid_list = [u.strip() for u in uuids.split(",") if u.strip()]
    if not uuid_list:
        print("No valid UUIDs parsed; exiting.")
        return
    final_results = []
    for u in uuid_list:
        print(f"Testing UUID {u} on {device_address}...")
        try:
            test_results = await exploit_device(device_address, u)
            final_results.append({
                "device_address": device_address,
                "char_uuid": u,
                "test_results": test_results
            })
        except Exception as e:
            print(f"Error exploiting UUID {u}: {e}")
    save_exploit_results(final_results)

def option_visualise_exploits():
    """
    Option 6:
    Read all exploit results from the recent_exploit folder, aggregate them by test type,
    and produce an interactive bar chart. Clicking on a bar opens a new table
    listing the command and response for that test type.
    """
    results = load_all_exploit_results()
    if not results:
        print("No exploit results found.")
        return

    # Aggregate test results by test type (e.g., "Buffer Overflow", "Alphanumeric", etc.)
    test_summary = {}
    for res in results:
        if "test_results" in res and res["test_results"]:
            for test in res["test_results"]:
                test_name = test.get("test_name", "Unknown")
                test_summary.setdefault(test_name, []).append(test)
        elif "bruteforce" in res and res["bruteforce"]:
            test_summary.setdefault("Bruteforce", []).extend(
                [{"command": "N/A", "response": r} for r in res["bruteforce"]])
    
    types = list(test_summary.keys())
    counts = [len(test_summary[t]) for t in types]

    fig, ax = plt.subplots()
    bars = ax.bar(types, counts, color="skyblue", picker=True)
    ax.set_xlabel("Test Type")
    ax.set_ylabel("Number of Results")
    ax.set_title("Exploit Test Summary")
    plt.xticks(rotation=45)
    plt.tight_layout()

    def on_bar_pick(event):
        index = event.ind[0]
        test_type = types[index]
        details = test_summary[test_type]
        # Prepare table data with two columns: Command and Response.
        table_data = []
        for d in details:
            command = d.get("command", "N/A")
            response = d.get("response", "N/A")
            table_data.append([command, response])
        fig2, ax2 = plt.subplots(figsize=(12, max(4, len(table_data)*0.6)))
        ax2.axis("tight")
        ax2.axis("off")
        headers = ["Command", "Response"]
        table = ax2.table(cellText=table_data, colLabels=headers, loc="center")
        ax2.set_title(f"Details for {test_type} ({len(details)} results)", fontsize=14)
        plt.show()

    fig.canvas.mpl_connect("pick_event", on_bar_pick)
    plt.show()

def main_menu():
    """
    Displays a menu for bleshellexploit and runs the chosen option.
    """
    menu = """
BLE Shell Exploit Menu:
1. Exploit a device from a recent scan.
2. Exploit all devices from recent scan.
3. Bruteforce and scan a specific device.
4. Scan a specific device with these UUID(s).
5. Exit.
6. Visualise Exploits.
Choose an option: """
    while True:
        choice = input(menu).strip()
        if choice == "1":
            asyncio.run(option_exploit_single_device())
        elif choice == "2":
            asyncio.run(option_exploit_all_devices())
        elif choice == "3":
            asyncio.run(option_bruteforce_specific())
        elif choice == "4":
            asyncio.run(option_scan_specific_with_uuids())
        elif choice == "5":
            print("Exiting BLE Shell Exploit Menu.")
            break
        elif choice == "6":
            option_visualise_exploits()
        else:
            print("Invalid option. Please try again.")

if __name__ == "__main__":
    main_menu()